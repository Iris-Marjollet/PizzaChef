//
// Created by Sarah Zakon on 07/07/2023.
//

#include "PizzaManager.h"

const float PizzaManager::xVelocity = 20;

PizzaManager::PizzaManager() {
    score = 0;
    lives = 3;
}

std::vector<Pizza> PizzaManager::getPizzas(){
    return pizzas;
}
int PizzaManager::getScore(){
    return score;
}

int PizzaManager::getLives(){
    return lives;
}

void PizzaManager::setPool(PizzaPool pool){
    this->pool = pool;
}

void PizzaManager::setIngredients(std::vector<Ingredient> ingredients){
    this->ingredients = ingredients;
}



void PizzaManager::movePizzas(sf::RenderWindow& window, sf::Sprite lifeline, std::map<std::string, sf::Texture> textures){
    //cout << "here 2" << endl;
    bool pizzaNeedGeneration=false;
    for (Pizza& pizza: pizzas) {
        if (pizza.getCirclePosition().x >window.getSize().x * 0.65) { //we are at the end of the line
            if (!pizza.isComplete()) { // If the pizza is not completed with all ingredients
                score -= 10;
                lives -= 1;
            } else {
                score += 10;
            }
            releasePizza(pizza);
            break;


        } else if (pizza.getCirclePosition().x > window.getSize().x * 0.2) { //we need to display a new pizza
            if (pizza.getCriticalStatePassed() == 0 && !pizzaNeedGeneration) {
                //cout << "new pizza generated by pizza " << pizza.getId() << endl;
                //cout << "before set new pizza " << pizza.getId() << " generator: " << pizza.getCriticalStatePassed() << endl;
                pizza.setCriticalStatePassed();
                pizzaNeedGeneration=true;
                //cout << "after set new pizza generator: " << pizza.getCriticalStatePassed() << endl;
                pizza.movePizza(xVelocity);
            }
            pizza.movePizza(xVelocity);

        } else {
            pizza.movePizza(xVelocity);
        }
    }
    if (pizzaNeedGeneration)
        pizzaGenerator();
}

void PizzaManager::randomIngr(Pizza pizza){ //PM
    std::random_device rd;
    std::mt19937 mt(rd());
    std::vector<int> values = {0, 1};
    std::uniform_int_distribution<int> distribution(0, 1);
    int randomIndex = distribution(mt);
    int numIngredients = values[randomIndex];
    if (numIngredients == 1){
        std::vector<Ingredient> ingrs;
        for (auto& ingredient: ingredients){
            ingrs.push_back(ingredient);
        }
        std::random_device rd1;
        std::mt19937 mt1(rd1());

        std::uniform_int_distribution<int> distribution(0, ingredients.size() - 1);
        int randomIndex1 = distribution(mt1);
        Ingredient ingredient = ingrs[randomIndex1];

        addRandomIngredient(pizza, ingredient);
    }

}

bool PizzaManager::checkPizzaClick(std::optional<Kitchen> selected, sf::Vector2i mousePos) {
    //cout << "check pizza click" << endl;
    for (auto &pizza: pizzas) {
        if (pizza.getDough().getGlobalBounds().contains(mousePos.x, mousePos.y)) {
            cout << "PIZZA TOUCHED: pizza id: " << pizza.getId() << endl;
            score += pizza.addIngredient(selected->getIngredient());
            return true;
        }
    }
    return false;
}
/*
void PizzaManager::addIngredient(std::optional<Kitchen> selected, std::string selected_type, Pizza& pizza){
    if (selected_type == "preparation") {
        score += pizza.addIngredient(selected->getIngredient());
        //cout << "circles length at the end of addIngredient pizza in facade: " << pizza.getCircles().size() << endl;
        for(auto& prep : preparations) {
            if(selected->getIngredient() == prep.second.getIngredient() && prep.second.getSelected() == true && selected->getPrepId() == prep.second.getPrepId()) {
                prep.second.reset();
            }
        }
    }
}*/

void PizzaManager::addRandomIngredient(Pizza pizza, Ingredient ingredient) {  //PM
    pizza.addIngredient(ingredient);
}





void PizzaManager::pizzaGenerator(){ //PM
    Pizza pizza = pool->acquirePizza();
    randomIngr(pizza);
    //Piz piz = {pizza, false};

    pizzas.push_back(pizza);

}


void PizzaManager::releasePizza(Pizza pizza){
    cout << "error 1" << endl;
    pizza.resetPizza();
    cout << "error 2" << endl;
    int pizzasIndex = 0;
    for (auto piz: pizzas){
        cout << "error 3" << endl;
        if(pizza == piz){

            //pizzas.erase(pizzas.begin());
            pizzas.erase(std::remove(pizzas.begin(), pizzas.end(), pizza), pizzas.end());
            cout << "error 4" << endl;
            break;
        }
        cout << "error 5" << endl;
        pizzasIndex++;
    }
    pool->releasePizza(pizza);
    cout << "error 6" << endl;
}

void PizzaManager::printPizza(sf::RenderWindow& window){
    for (auto& pizza: pizzas) {
        //cout << "print pizza" << endl;
        pizza.printPizza(window);
        //cout << "after print pizza in FACADE " << pizza.getDough().getPosition().x << endl;
    }

}
